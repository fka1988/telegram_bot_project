import os
import logging
import random
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from supabase import create_client, Client
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes,
    filters, ConversationHandler
)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
TEACHER_CODE = "2308"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–π
if not BOT_TOKEN or not SUPABASE_URL or not SUPABASE_KEY:
    raise RuntimeError("–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è BOT_TOKEN, SUPABASE_URL –∏–ª–∏ SUPABASE_KEY –Ω–µ –∑–∞–¥–∞–Ω—ã.")

# Supabase –∫–ª–∏–µ–Ω—Ç
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# –°–æ—Å—Ç–æ—è–Ω–∏—è
SELECT_ROLE, TEACHER_AUTH, HANDLE_TEST_UPLOAD, ADD_OR_KEY, ENTER_FEEDBACK_MODE, STUDENT_ENTER_CODE, STUDENT_ENTER_ANSWERS = range(7)

# –õ–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —Ñ–∞–π–ª–æ–≤
BASE_DIR = Path("tests")
BASE_DIR.mkdir(exist_ok=True)

# /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.clear()
    keyboard = [["üë®‚Äçüè´ –Ø —É—á–∏—Ç–µ–ª—å", "üßë‚Äçüéì –Ø —É—á–µ–Ω–∏–∫"]]
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É —Ä–æ–ª—å:",
        reply_markup=ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True),
    )
    return SELECT_ROLE

async def select_role(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text.strip()
    if text == "üë®‚Äçüè´ –Ø —É—á–∏—Ç–µ–ª—å":
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è:")
        return TEACHER_AUTH
    elif text == "üßë‚Äçüéì –Ø —É—á–µ–Ω–∏–∫":
        context.user_data["role"] = "student"
        await update.message.reply_text("‚úÖ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —É—á–µ–Ω–∏–∫.\n–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ —Ç–µ—Å—Ç–∞:")
        return STUDENT_ENTER_CODE
    elif text == "‚úÖ –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç":
        return await start_test_upload(update, context)
    elif text == "üìò –ú–æ–∏ —Ç–µ—Å—Ç—ã":
        await mytests(update, context)
        return SELECT_ROLE
    elif text == "üë§ –û —Å–µ–±–µ":
        await teacher_info(update, context)
        return SELECT_ROLE
    else:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –æ–ø—Ü–∏–π.")
        return SELECT_ROLE

async def teacher_auth(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == TEACHER_CODE:
        context.user_data["role"] = "teacher"
        await update.message.reply_text(
            "‚úÖ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.",
            reply_markup=ReplyKeyboardMarkup(
                [["‚úÖ –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç"], ["üìò –ú–æ–∏ —Ç–µ—Å—Ç—ã"], ["üë§ –û —Å–µ–±–µ"]],
                resize_keyboard=True
            )
        )
        return SELECT_ROLE
    else:
        await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —É—á–µ–Ω–∏–∫.")
        context.user_data["role"] = "student"
        return STUDENT_ENTER_CODE

async def start_test_upload(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    test_id = str(random.randint(1000, 9999))
    context.user_data["test_id"] = test_id
    await update.message.reply_text(
        "üìé –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª —Ç–µ—Å—Ç–∞ (PDF –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ).",
        reply_markup=ReplyKeyboardRemove()
    )
    return HANDLE_TEST_UPLOAD

async def handle_test_upload(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.message.from_user.id
    test_id = context.user_data["test_id"]
    test_dir = BASE_DIR / str(user_id) / test_id
    test_dir.mkdir(parents=True, exist_ok=True)

    file = update.message.document or (update.message.photo[-1] if update.message.photo else None)
    if not file:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ PDF –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
        return HANDLE_TEST_UPLOAD

    file_obj = await file.get_file()
    file_name = getattr(file, "file_name", f"{file.file_id}.jpg")
    file_path = test_dir / file_name
    await file_obj.download_to_drive(custom_path=str(file_path))

    await update.message.reply_text(
        f"‚úÖ –§–∞–π–ª {file_name} —Å–æ—Ö—Ä–∞–Ω—ë–Ω.\n–ö–æ–¥ —Ç–µ—Å—Ç–∞: {test_id}\n\n–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë –∏–ª–∏ –≤–≤–µ—Å—Ç–∏ –∫–ª—é—á?",
        reply_markup=ReplyKeyboardMarkup([["‚ûï –ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë", "‚úÖ –ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–≤–æ–¥—É –∫–ª—é—á–∞"]], resize_keyboard=True)
    )
    return ADD_OR_KEY

async def add_or_enter_key(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text.strip()
    if "–µ—â—ë" in text:
        await update.message.reply_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
        return HANDLE_TEST_UPLOAD
    elif "–∫–ª—é—á" in text.lower():
        await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –æ—Ç–≤–µ—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä: abcdabcd):",
            reply_markup=ReplyKeyboardRemove()
        )
        return ENTER_FEEDBACK_MODE
    else:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.")
        return ADD_OR_KEY

async def enter_feedback_mode(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    answers = update.message.text.strip()
    context.user_data["answers"] = answers

    user_id = update.message.from_user.id
    test_id = context.user_data["test_id"]
    test_dir = BASE_DIR / str(user_id) / test_id
    test_dir.mkdir(parents=True, exist_ok=True)

    with open(test_dir / "answers.key", "w", encoding="utf-8") as f:
        f.write(answers)

    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏:",
        reply_markup=ReplyKeyboardMarkup([
            ["üìä –ö–æ—Ä–æ—Ç–∫–∏–π (—Ç–æ–ª—å–∫–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç)"],
            ["üìã –†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π (–≤–µ—Ä–Ω–æ/–Ω–µ–≤–µ—Ä–Ω–æ)"],
            ["üìò –ü–æ–ª–Ω—ã–π (–≤–µ—Ä–Ω–æ/–Ω–µ–≤–µ—Ä–Ω–æ + –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç)"]
        ], one_time_keyboard=True, resize_keyboard=True)
    )
    return ENTER_FEEDBACK_MODE

async def feedback_mode_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    mode = update.message.text.strip()
    user_id = update.message.from_user.id
    test_id = context.user_data["test_id"]
    test_dir = BASE_DIR / str(user_id) / test_id

    if "—Ç–æ–ª—å–∫–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç" in mode:
        mode_value = "short"
    elif "—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π" in mode.lower():
        mode_value = "detailed"
    else:
        mode_value = "full"

    with open(test_dir / "feedback.mode", "w", encoding="utf-8") as f:
        f.write(mode_value)

    count = len(context.user_data["answers"])
    author_name = update.effective_user.full_name or update.effective_user.username or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    now = datetime.now()

    await update.message.reply_text(
        f"‚úÖ –¢–µ—Å—Ç –¥–æ–±–∞–≤–ª–µ–Ω.\n–ê–≤—Ç–æ—Ä: {author_name}\n–ö–æ–¥: {test_id}\n–í–æ–ø—Ä–æ—Å–æ–≤: {count}\nüìÜ {now.strftime('%d.%m.%Y')} ‚è∞ {now.strftime('%H:%M')}",
        reply_markup=ReplyKeyboardMarkup(
            [["‚úÖ –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç"], ["üìò –ú–æ–∏ —Ç–µ—Å—Ç—ã"], ["üë§ –û —Å–µ–±–µ"]],
            resize_keyboard=True
        )
    )

    try:
        supabase.table("tests").insert({
            "test_id": test_id,
            "author_id": user_id,
            "answers": context.user_data["answers"],
            "feedback_mode": mode_value,
            "created_at": now.isoformat(),
            "author_name": author_name
        }).execute()
        logging.info(f"–¢–µ—Å—Ç {test_id} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ Supabase.")
    except Exception as e:
        logging.warning(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Supabase: {e}")

    return SELECT_ROLE

async def student_enter_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["test_code"] = update.message.text.strip()
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–∏ –æ—Ç–≤–µ—Ç—ã:")
    return STUDENT_ENTER_ANSWERS

async def student_enter_answers(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    student_answers = update.message.text.strip()
    test_code = context.user_data.get("test_code")
    found = False

    for user_folder in BASE_DIR.iterdir():
        test_folder = user_folder / test_code
        if test_folder.exists():
            found = True
            break

    if not found:
        await update.message.reply_text("–ö–ª—é—á –¥–ª—è —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return ConversationHandler.END

    try:
        with open(test_folder / "answers.key", "r", encoding="utf-8") as f:
            correct_answers = f.read().strip()
        with open(test_folder / "feedback.mode", "r", encoding="utf-8") as f:
            mode = f.read().strip()
    except:
        await update.message.reply_text("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∫–ª—é—á–∞.")
        return ConversationHandler.END

    if len(student_answers) != len(correct_answers):
        await update.message.reply_text("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç.")
        return ConversationHandler.END

    correct_count = sum(sa == ca for sa, ca in zip(student_answers, correct_answers))

    if mode == "short":
        await update.message.reply_text(f"‚úÖ –í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {correct_count} –∏–∑ {len(correct_answers)}")
    elif mode == "detailed":
        result = [f"{i+1}) {'‚úÖ' if sa == ca else '‚ùå'}" for i, (sa, ca) in enumerate(zip(student_answers, correct_answers))]
        await update.message.reply_text("\n".join(result))
    else:
        result = [f"{i+1}) {'‚úÖ' if sa == ca else f'‚ùå (–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: {ca})'}" for i, (sa, ca) in enumerate(zip(student_answers, correct_answers))]
        await update.message.reply_text("\n".join(result))

    return ConversationHandler.END

async def reset(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.clear()
    return await start(update, context)

async def mytests(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    user_dir = BASE_DIR / str(user_id)
    if not user_dir.exists():
        await update.message.reply_text("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Ç–µ—Å—Ç–æ–≤.")
        return

    test_dirs = sorted(user_dir.iterdir())
    if not test_dirs:
        await update.message.reply_text("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Ç–µ—Å—Ç–æ–≤.")
        return

    messages = []
    for test_dir in test_dirs:
        test_id = test_dir.name
        key_path = test_dir / "answers.key"
        mode_path = test_dir / "feedback.mode"
        if not key_path.exists():
            continue
        try:
            with open(key_path, "r", encoding="utf-8") as f:
                count = len(f.read().strip())
        except:
            count = "?"
        try:
            with open(mode_path, "r", encoding="utf-8") as f:
                mode = f.read().strip()
        except:
            mode = "?"
        date_str = datetime.fromtimestamp(test_dir.stat().st_ctime).strftime("%d.%m.%Y")
        messages.append(f"üìò –¢–µ—Å—Ç {test_id}: {count} –≤–æ–ø—Ä. ‚Ä¢ –†–µ–∂–∏–º: {mode} ‚Ä¢ üìÜ {date_str}")

    await update.message.reply_text("üìö –í–∞—à–∏ —Ç–µ—Å—Ç—ã:\n\n" + "\n".join(messages))

async def teacher_info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    await update.message.reply_text(
        f"üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å —É—á–∏—Ç–µ–ª—è:\n"
        f"–ò–º—è: {user.full_name}\n"
        f"Username: @{user.username or '‚Äî'}\n"
        f"ID: {user.id}"
    )

def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SELECT_ROLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_role)],
            TEACHER_AUTH: [MessageHandler(filters.TEXT & ~filters.COMMAND, teacher_auth)],
            HANDLE_TEST_UPLOAD: [MessageHandler(filters.Document.ALL | filters.PHOTO, handle_test_upload)],
            ADD_OR_KEY: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_or_enter_key)],
            ENTER_FEEDBACK_MODE: [
                MessageHandler(filters.Regex("^(üìä|üìã|üìò)"), feedback_mode_selection),
                MessageHandler(filters.TEXT & ~filters.COMMAND, enter_feedback_mode),
            ],
            STUDENT_ENTER_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, student_enter_code)],
            STUDENT_ENTER_ANSWERS: [MessageHandler(filters.TEXT & ~filters.COMMAND, student_enter_answers)],
        },
        fallbacks=[CommandHandler("reset", reset)],
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("reset", reset))
    app.add_handler(CommandHandler("mytests", mytests))

    app.run_polling()

if __name__ == "__main__":
    main()
